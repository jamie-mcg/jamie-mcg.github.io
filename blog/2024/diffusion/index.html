<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Diffusion | Jamie McGowan </title> <meta name="author" content="Jamie McGowan"> <meta name="description" content="A comprehensive look at the theory and concepts underpinning diffusion models."> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/artificial-intelligence.png?696be420326cea5b9a828337e7a77226"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://jamie-mcg.github,io/blog/2024/diffusion/"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?0afe9f0ae161375728f7bcc5eb5b4ab4"></script> </head> <body class="fixed-top-nav sticky-bottom-footer"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Jamie </span> McGowan </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-solid fa-moon"></i> <i class="fa-solid fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Diffusion</h1> <p class="post-meta"> January 29, 2024 </p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/tag/math"> <i class="fa-solid fa-hashtag fa-sm"></i> math</a>   <a href="/blog/tag/diffusion"> <i class="fa-solid fa-hashtag fa-sm"></i> diffusion</a>     ·   <a href="/blog/category/deep"> <i class="fa-solid fa-tag fa-sm"></i> deep</a>   <a href="/blog/category/learning"> <i class="fa-solid fa-tag fa-sm"></i> learning</a>   </p> </header> <article class="post-content"> <div id="markdown-content"> <p>Generative Models are a class of networks which have left many of us spell-bounded in recent years. These models have propelled Artificial Intelligence (AI) into popular culture and captivated the general public by their attempts to encapsulate something inately human; <em>creativity</em>.</p> <p>In parallel to many intricate “under-the-hood” technical advancements, the humanisation of AI has played a major role in driving the popularity of generative models. The ease of use and access to some of the most powerful AI tools the world has seen, has motivated a widespread adoption of generative models into many services and third-party applications.</p> <p>Indeed, as Uncle Ben would rightly say:</p> <p><em>with great power, comes great responsibility</em></p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blogs/diffusion/giphy-480.webp 480w,/assets/img/blogs/diffusion/giphy-800.webp 800w,/assets/img/blogs/diffusion/giphy-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/blogs/diffusion/giphy.gif" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Spider-man classic scene, image available <a href="https://media2.giphy.com/media/v1.Y2lkPTc5MGI3NjExejdpdHBobW94Y2RmYWw1NHNjc3VjZzk0OTR3MDB2Ymg1OWNkc3o5ayZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/10KIsXhwdoerHW/giphy.gif" rel="external nofollow noopener" target="_blank">here</a>. </div> <p>and AI is no exception, with many of these new possibilities bringing with them contraversies and a new requirement for AI governance.</p> <p>Anyway, we can cover AI safety and governance in another blog post. For now, in this post, I want to explain how diffusion models really work and discuss some of their incredible applications.</p> <h2 id="problem-setup">Problem Setup</h2> <p>As with all Machine Learning problems, we must start with the data! The goal of generative modelling solutions is to find some model for the data distribution such that generated outputs lie within the distribution of inputs.</p> <p>Let’s just contextualise that with an example: say I asked you to imagine a car. It is highly likely that the image you choose to imagine would be similar to those you have seen in the past. In this case, your brain has a model of what a car should look like, that has been learnt from all your experience of seeing cars in the past. Therefore we can say that, the imagined output has a high probability of being close to one which is realistic to find in the wild.</p> <p>To be clear, this doesn’t mean that we can imagine exactly a particular image of a car and reproduce it in our head (unless you are a slightly obsessive petrolhead…), it means we recognise the key concepts that are required for a car to be, well… a car, and we are able to compose these concepts together into something that resembles a car. Indeed, our model is not discrete and is also able to interpolate between many concepts to produce something entirely different to what we may have seen in the past. Without sounding too philisophical, this is arguably one of the pillars of human-like creativity, the compositionality of learned concepts.</p> <p>Now let’s just round off this section by stating some mathematical definitions which will be useful later.</p> <p>Let $x \in RR^d$ be our data with dimension $d$ which is obtained from some underlying distribution $q_{\text{data}}(x)$. The goal of a generative model is to estimate $p(x)$ which approximates the true data distribution $q_{\text{data}}(x)$.</p> <p>Here is an example of a model fabricating some image out of thin air!</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blogs/diffusion/diffusion_process-480.webp 480w,/assets/img/blogs/diffusion/diffusion_process-800.webp 800w,/assets/img/blogs/diffusion/diffusion_process-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/blogs/diffusion/diffusion_process.gif" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Figure created by author with astronaut image from `skimage`. </div> <p>So, how do we do this?</p> <h2 id="setting-up-the-training-algorithm">Setting up the training algorithm</h2> <p>We have data, but we don’t have any labels, so at the moment we’re in an unsupervised regime. Typically learning from unsupervised data tends to be quite hard and is also somewhat hard to control - since you are leaving the model up to its own devices.</p> <p>A much easier problem would be a supervised task, so let’s try and set one of these up from the ingredients we have.</p> <p>In much the same way as you would start from a blank page when asked to draw a picture, we can ask our probabilistic model to do the same. In this setting, we have the input as a randomised vector of the same dimension of $x$ and $x$ becomes our target! Voila!</p> <p>Right, before we get confused, lets add to our math we had earlier, just so we can digest this.</p> <p>Let our data be $x^{(0)}$ and our starting point (blank page/random vector) be $x^{(T)}$. Apologies for the cryptic notation, I promise this notation will become clearer later…</p> <table> <tbody> <tr> <td>The problem we have set up is $x^{(0)} \sim p(x^{(0)}</td> <td>x^{(T)})$ as an approximation to $x \sim q(x)$.</td> </tr> </tbody> </table> <p>Hmm… this still seems super hard though, right? If I asked you to go from a blank page to a masterpiece in a single step, unless you were Picasso, you would quite clearly struggle. So let’s break it up, step-by-step.</p> <p>Instead of going from $x^{(T)} \rightarrow x^{(0)}$ in 1 step, lets say it takes $T$ steps:</p> \[x^{(0)} \leftarrow x^{(1)} \leftarrow \dots \leftarrow x^{(t-1)} \leftarrow x^{(t)} \leftarrow \dots \leftarrow x^{(T-1)} \leftarrow x^{(T)}\] <table> <tbody> <tr> <td>where now we can define a much simpler regression problem at each step, which can be modelled by $x^{(t-1)} \sim p(x^{(t-1)}</td> <td>x^{(t)})$. With this, we can write the marginal distribution as:</td> </tr> </tbody> </table> \[p(x^{(0)}) = \int p(x^{(T)}) p(x^{(0)}|x^{(1)}) \dots p(x^{(T-1)}|x^{(T)}) dx^{(1)} \dots dx^{(0)} \\ = \int p(x^{(T)}) \prod_{t=1}^{T} p(x^{(t-1)}|x^{(t)}) dx^{(t)} \\ = \int p(x^{(0:T)}) dx^{(1:T)}\] <p>where the last line is a commonly used shorthand for the concatenation of variables across timesteps.</p> <p>OK, so the math checks out that as long as we obey the time ordering i.e. $x^{(T)}$ being the worst, $x^{(0)}$ being the best and $t=T-1,\dots 1$ being progressively better versions of $x$.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blogs/diffusion/diffusion_process-480.webp 480w,/assets/img/blogs/diffusion/diffusion_process-800.webp 800w,/assets/img/blogs/diffusion/diffusion_process-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/blogs/diffusion/diffusion_process.gif" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Figure created by author with astronaut image from `skimage`. </div> <h2 id="creating-xt">Creating $x^{(t)}$</h2> <p>The first problem we have is that $x^{(0)} \sim q(x^{(0)})$ is a perfect data sample, so how do we go about getting our hands on $x^{(t)} \forall t \in {1, \dots, T}$.</p> <p>This is where “noising” comes in!</p> <p>The data creation process for our litter regression problems will involve noising our perfect data $x^{(0)}$ by a small amount over $T$ steps, until we reach $x^{(T)}$.</p> <table> <tbody> <tr> <td>We will denote the noising process as $q(x^{(t)}</td> <td>x^{(t-1)})$ and define it as a first order Gaussian which performs the transformation:</td> </tr> </tbody> </table> \[x^{(t)} = \lambda_t x^{(t-1)} + \sigma_t \epsilon_t \qquad \epsilon \sim \mathcal{N}(0,1) \\ q(x^{(t)}|x^{(t-1)}) = \mathcal{N}(x^{(t)}; \lambda_t x^{(t-1)}, \sigma_t^2)\] <p>Great! We now have our noising and denoising processing written down!</p> <p>Let’s see an example of how these probabilities are related. Below is an example of how one can start with some data distribution $q(x^{(0)})$ (with two distinct distributions) and end up with some noised Gaussian distibution - where all evidence of the original data has gone.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blogs/diffusion/diffusion_process_probability-480.webp 480w,/assets/img/blogs/diffusion/diffusion_process_probability-800.webp 800w,/assets/img/blogs/diffusion/diffusion_process_probability-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/blogs/diffusion/diffusion_process_probability.gif" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Figure created by author. </div> <h2 id="how-do-we-noise-this-thing">How do we noise this thing?</h2> <p>In order to actually use this noising process, we need to first define $\lambda_t$ and $\sigma_t$. If we stop and think about what these parameters actually mean for a second, we might be able to gain some insight.</p> <ul> <li>$\lambda_t \rightarrow 0$ means that we forget all information and only have noise</li> <li>$\lambda_t = 1$ means we retain the information in $x^{(t-1)}$</li> </ul> <p>We want $x^{(T)}$ to contain zero information, since $x^{(T)}$ is our blank canvas which we want to easily sample from whatever we want to generate something new.</p> <p>In this sense, we would like $\lambda_t &lt; 1$, but we want to keep small regression tasks as simple as possible - not lose too much information at each step. So we might want to have $\lambda_t$ somewhere close to 1 in practice.</p> <p>As long as $\lambda_t &lt; 1$, for $T \rightarrow \infty$, we are guaranteed to get $x^{(T)}$ as pure noise! - a perfect blank canvas for an ML model.</p> <p>Similarly for $\sigma_t$, this controls the amount of noise that is added at each step. Something we might want to put $\sim 0$ for the same reasons as above.</p> <p>A common choice is to set $\sigma_t^2 = 1 - \lambda_t^2$, which for now we will motivate by saying that when $\lambda_t \ge 1$, $\sigma_t^2 \ge 0$. But it is actually theoretically justified by guaranteeing that $\mathbb{E}<em>{q(x^{(t)})}[x^{(t)}] = 0$ and $\mathbb{E}</em>{q(x^{(t)})}[(x^{(t)})^2] = 1$.</p> <h3 id="variance-preserving-process">Variance Preserving Process</h3> <p>Aside: $\sigma_t^2 = 1 - \lambda^2<em>t$ ensures that $\mathbb{E}</em>{q(x^{(t)})}[x^{(t)}] = 0$ and $\mathbb{E}_{q(x^{(t)})}[(x^{(t)})^2] = 1$.</p> <p>We know that the data satisfies:</p> \[\mathbb{E}_{q(x^{(0)})}[x^{(0)}] = 0 \quad \text{and} \quad \mathbb{E}_{q(x^{(0)})}[(x^{(0)})^2] = 1\] <p>because it can be normalised to do so. So let’s consider $x^{(1)}$:</p> \[\mathbb{E}_{q(x^{(1)})}[x^{(1)}] = \mathbb{E}[\lambda_1 x^{(0)} + \sigma_1 \epsilon_1] = \lambda_1 \mathbb{E}[x^{(0)}] + \sigma_1 \mathbb{E}[\epsilon_1] = 0\] <p>because $\epsilon_1 \sim \mathcal{N}(0, 1)$. And also:</p> \[\mathbb{E}_{q(x^{(1)})}[(x^{(1)})^2] = \mathbb{E}[\lambda_1^2 (x^{(0)})^2 + \sigma_1^2 \epsilon_1^2] = \lambda_1^2 \mathbb{E}[(x^{(0)})^2] + \sigma_1^2 \mathbb{E}[\epsilon_1^2] = \lambda_1^2 + \sigma_1^2 \\ \therefore \mathbb{E}_{q(x^{(1)})}[(x^{(1)})^2] = 1 \iff \sigma_1^2 = 1-\lambda_1^2\] <p>By recursion, we can see that this is true for all $t$.</p> <p>In this case, when the process is variance preserving, we can write down:</p> \[q(x^{(t)}|x^{(0)}) = \mathcal{N}(x^{(t)}; \prod_{i=1}^{t} \lambda_{i} x^{(0)}, 1 - \prod_{i=1}^{t}\lambda_t^2)\] <table> <tbody> <tr> <td>which can be proved by unrolling $q(x^{(t)}</td> <td>x^{(t-1)})$, if you fancy doing some rather laborious maths.</td> </tr> </tbody> </table> <p>OK, now we are getting somewhere. We have a problem setup, we have our chain of makeshift supervised regression problems and we know how to generate the noisey labels for each of these regression problems. Indeed, from the above, we can even generate any noisey sample at any point in this chain, directly from the input $x^{(0)}$, as long as we have a variance preserving process!</p> <p>Practically, this means that we do not need to generate <em>all</em> the previous $[x^{(1)}, \dots x^{(t-1)}]$ just to get $x^{(t)}$, which will become important later when we talk about training!</p> <p>Just one thing to note here before we move on to the next section is that; in order for us to generate $x^{(0)}$ from $x^{(T)}$, which is essentially the aim of a diffusion model, we still require $x^{(T)}$ to be an <em>easy</em> sample to generate. To put this another way, when we deploy this model we will not have access to $x^{(0)}$, we need to generate it! So our starting point $x^{(T)}$ should ideally not have any information about $x^{(0)}$ left inside it, it should be complete noise - which is super easy to generate independent of any other sample in the chain.</p> <p>The above requirement basically tells us that we’re going to run into a balancing act between how <em>hard</em> we make each regression problem (how much noise we add per-step) and how many timesteps can afford to do. Anyway, more on this later!</p> <h2 id="defining-a-loss">Defining a Loss</h2> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blogs/diffusion/generated_samples-480.webp 480w,/assets/img/blogs/diffusion/generated_samples-800.webp 800w,/assets/img/blogs/diffusion/generated_samples-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/blogs/diffusion/generated_samples.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Figure created by author. </div> <p>Taking a step back, we have a dataset that now consists of lots of ordered noisey samples which need to be assigined to a particular regression step in our denoising schedule (i.e., going from $T \rightarrow$ 0).</p> <p>To play aroung a bit, lets simply define a loss which concatenates all of our small regression tasks, each with their own set of parameters $\Theta = {\theta_t}_{t\in [0, T-1]}$.</p> \[\mathcal{L}(\Theta) = \mathbb{E}_q \log\left\{p(x^{(T)}) \prod_{t=1}^{T} p_{\theta_{t-1}}(x^{(t-1)}|x^{(t)}) \right\} \\ =\mathbb{E}_q \left[\log p(x^{(T)})\right] + \sum_{t=1}^{T} \mathbb{E}_q \left[\log p_{\theta_{t-1}}(x^{(t-1)}|x^{(t)})\right]\] <table> <tbody> <tr> <td>where it is the second term which depends on the parameters, so an individual regression loss would be $\mathcal{L}(\theta_{t-1}) = \mathbb{E}<em>q \left[\log p</em>{\theta_{t-1}}(x^{(t-1)}</td> <td>x^{(t)})\right]$.</td> </tr> </tbody> </table> <p>OK cool, so as we are all excellent researchers and like to think about the implications of our maths before whacking it into some code… Let’s just have a think about the complexity of the above formalism.</p> <p>Let $\theta_t \in \mathbb{R}^d$, then we will end up with a total parameter count of $T \times d$. OK, so this means that as the number of timesteps increases, this model is going to scale linearly and as $T \rightarrow \infty$, become intractable.</p> <p>OK, you’re right, we’ll never be actually taking $T \rightarrow \infty$ in practice. But we do need it to be pretty large to satisfy the requirements we discussed earlier, so its still a problem. One way we can try to solve this problem is <em>weight sharing</em>.</p> <p>From now on, we will define one set of weights for all timesteps $\theta_t \rightarrow \theta$, which reduces the total parameters to just $d$. This is not only motivated from a computational perspective, but also by the fact that if we have defined our chain of regression tasks correctly, they are all kind of doing the same thing. So intuitively, there should be some redundancy across timesteps.</p> <p>After all this, we can make a minimal adjustment to our individual loss function:</p> \[\mathcal{L}_{t-1}(\theta) = \mathbb{E}_q \left[\log p_{\theta}(x^{(t-1)}|x^{(t)})\right].\] <p>Right, last thing for this section, how do we add some control to this training? Let me explain…</p> <p>Simply summing all the individual losses for each step in our chain is fine, but it weights each step equally in terms of its feedback to $\theta$ - which are now shared across timesteps. However, you can imagine that there might be some steps that need to be <em>more accurate</em> than others in our chain.</p> <p>In order to add some contol, we will introduce some weighting parameters $w_t$ into our total loss which control how much each step contributes to updating $\theta$:</p> \[\theta^{*} = \text{argmin}_{\theta} \sum_{t=1}^{T} w_{t-1} \mathcal{L}_{t-1}(\theta)\] <h2 id="the-magic-of-stochastic-optimization">The Magic of Stochastic Optimization</h2> <p>Right now, you’re probably thinking, how much more can there be to this! But honestly, this is one of my favourite tricks that is used all over Machine Learning. Its super simple but when I first started learning about diffusion models, understanding how they leverage stochastic optimization made me think about the time axis (and also the sequence axis in transformers) in a much clearer way.</p> <p>Anyway, the above update rule has a sum over $T$ terms, all of which require varying numbers of passes through the network. This is fine but because we are sharing weights across timesteps, we can do better.</p> <p>To gain an intuition, lets go back to thinking about batches of data and training a very simple neural network with parameters $\theta$. Imagine our dataset $\mathcal{D}$ contains $N_\mathcal{D}$ samples. Theoretically, this gives us a solution of the form:</p> \[\theta^{*} = \text{argmin}_{\theta} \frac{1}{N} \sum_{n=1}^{N} w_{n} \mathcal{L}_{n}(\theta)\] <p>where $w_n$ are weighting scalars for how much each sample contributes - this could be related to the quality of that datapoint for example.</p> <p>This looks very similar to the equation we just wrote down for diffusion models, right? But in training a neural network we don’t need see <em>all</em> the $N_\mathcal{D}$ samples, we usually get away with defining a some batches and approximating the weighted sum via an expectation over the data:</p> \[\frac{1}{N} \sum_{n=1}^{N} w_{n} \mathcal{L}_{n}(\theta) = \mathbb{E}_{n \sim \mathcal{U}(1,N)}[w_n \mathcal{L}_{n}(\theta)]\] <p>This trick is possible because the parameters are shared across mini-batches. But remember, in our diffusion setup, we are also sharing parameters across $T$ timesteps, so we can employ exactly the same trick!</p> \[\theta^{*} = \text{argmin}_{\theta} \sum_{t=1}^{T} w_{t-1} \mathcal{L}_{t-1}(\theta) = \text{argmin}_{\theta} \left\{\mathbb{E}_{t \sim \mathcal{U}(1, T)} \left[w_{t-1} \mathcal{L}_{t-1}(\theta)\right]\right\}\] <p>Hooray, now we don’t need ALL $T$ terms! We can just sample timesteps randomly from a uniform distribution. But remember, because we have a variance preserving process, we can get the target for the sampled timestep directly from the data $x^{(0)}$.</p> <h2 id="the-denoising-step">The Denoising Step</h2> <p>Now we come to the denoising part of our pipeline… Finally!</p> <p>In this part, the goal is to learn the noise which we want to remove at each step. However, because we have already defined the noising schedule with a Gaussian we can also parameterise the noise to remove similarly:</p> \[p(x^{(t-1)}|x^{(t)}; t-1, \theta) = \mathcal{N}(x^{(t-1)};\mu_{\theta}(x^{(t)}; t-1), \sigma_{\theta}^{2}(x^{(t)}; t-1))\] <p>This leaves us with two terms to deal with here; the mean and the variance.</p> <p>For the mean, we can do this by either; (i) directly parameterising $x^{(0)}$ at each step, or (ii) by parameterising the noise directly $\epsilon^{(t)}$.</p> <h3 id="i-x0-parameterisation">i. $x^{(0)}$-parameterisation</h3> <table> <tbody> <tr> <td>This method involves looking at the noising step $q(x^{(t-1)}</td> <td>x^{(0)}, x^{(t)})$ where from Bayes rule, we have:</td> </tr> </tbody> </table> \[q(x^{(t-1)}|x^{(0)}, x^{(t)}) \propto q(x^{(t-1)}|x^{(0)})q(x^{(t)}|x^{(t-1)}) \\ = \mathcal{N}\left( x^{(t-1)};\ \left(\prod_{t^\prime = 1}^{t-1} \lambda_{t^\prime} x^{(0)} \right),\ 1 - \prod_{t^\prime = 1}^{t-1} \lambda_{t^{\prime}}^{2} \right) \times \mathcal{N}(x^{(t)};\ \lambda_t x^{(t-1)}, \ 1-\lambda_t^2)\] <table> <tbody> <tr> <td>then completing the square and doing some mathematical gymnastics gives us a new distribution $q(x^{(t-1)}</td> <td>x^{(0)}, x^{(t)}) = \mathcal{N}(x^{(t-1)}; \mu_{t-1</td> <td>0,t}, \sigma_{t-1</td> <td>0,t}^{2})$ where:</td> </tr> </tbody> </table> \[\mu_{t-1|0,t} = \frac{\left(\prod_{t^\prime = 1}^{t-1} \lambda_{t^\prime}\right)(1-\lambda_t^2)}{1 - \prod_{t^\prime = 1}^{t} \lambda^2_{t^\prime}} x^{(0)} + \frac{\left(1 - \prod_{t^\prime = 1}^{t-1} \lambda^2_{t^\prime}\right)\lambda_t}{1 - \prod_{t^\prime = 1}^{t} \lambda^2_{t^\prime}}x^{(t)} \\ \sigma_{t-1|0,t}^{2} = \frac{\left(1 - \prod_{t^\prime = 1}^{t-1} \lambda^2_{t^\prime}\right)(1 - \lambda_t^2)}{1 - \prod_{t^\prime = 1}^{t} \lambda^2_{t^\prime}}\] <p>In the $x^{(0)}$-parameterisation, we do exactly what it says on the tin and parameterise $x^{(0)}$:</p> \[\mu_{t-1|0,t}^{\theta} = a^{(t)}x^{(0)}_{\theta}(x^{(t)}) + b^{(t)}x^{(t)}\] <h3 id="ii-epsilon-parameterisation">ii. $\epsilon$-parameterisation</h3> <p>An alternative parameterisation to the above is found by instead aiming to predict the noise $\epsilon$ at each step. Similarly to the $x^{(0)}$-parameterisation, our weight sharing is well-founded by the argument that each step is adding a similar amount of noise - so we can imagine some redundancy in the parameters across adjacent steps.</p> <p>If we cast our minds back to earlier, we had a noising schedule which can be written as:</p> \[x^{(t)} = \prod_{t^\prime = 1}^{t} \lambda_{t^\prime} x^{(0)} + \sqrt{1-\prod_{t^\prime = 1}^{t}\lambda_{t^\prime}^{2}}\ \epsilon^{(t)} \qquad \epsilon^{(t)} \sim \mathcal{N}(0,1) \\ x^{(t)} = c^{(t)} x^{(0)} + d^{(t)} \epsilon^{(t)}\] <p>So if we take the conditional mean that we got from our $x^{(0)}$-parameterisation, we can easily substitue the above into this and write down a new expression of the form:</p> \[\mu_{t-1|0,t}^{\theta} = \left(\frac{a^{(t)}}{c^{(t)}} + b^{(t)}\right)x^{(t)} - \frac{a^{(t)}d^{(t)}}{c^{(t)}}\epsilon^{(t)}_{\theta}(x^{(t)})\] <p>So given the input and the timestep, our parameterisation now predicts the noise that needs to be taken away from $x^{(t)}$ in order to give $x^{(t-1)}$.</p> <p>OK, so hopefully its pretty easy to see how these two parameterisations are related to each other. In fact, you might be asking, <em>“what is the difference?”</em> or <em>“why would we want to do this?”</em> - these would be valid questions!</p> <p>To answer these a bit more in depth, we can consider how each one is actually performing the denoising step and at the same time, learn about some related work!</p> <h2 id="denoising-autoencoders-dae">Denoising Autoencoders (DAE)</h2> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blogs/diffusion/mnist_ae-480.webp 480w,/assets/img/blogs/diffusion/mnist_ae-800.webp 800w,/assets/img/blogs/diffusion/mnist_ae-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/blogs/diffusion/mnist_ae.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Autoencoder results from training to reconstruct MNIST digits. </div> <p>As discussed above, in the $x^{(0)}$-parameterisation, the goal is to predict the clean data $x^{(0)}$ from a noisy version $x^{(t)}$. The DAE is trained to map the noisy input $x^{(t)}$ to the clean output $x^{(0)}$. This process can be formulated as: \(x_{\theta}^{(0)} = f_{\theta}(x^{(t)})\)</p> <p>where $f_\theta$ is the neural network which parameterises $x_\theta^{(0)}$, $x^{(t)}$ is the noisy input at time step $t$, and $x^{(0)}$ is the predicted clean data.</p> <p>The training objective for the DAE in this context is to minimize the mean squared error (MSE) between the predicted clean data $x_{\theta}^{(0)}$ and the actual clean data $x^{(0)}$:</p> \[\mathcal{L}_{DAE} = \mathbb{E}_{x_0, t, \epsilon} \left[ | x^{(0)} - f_\theta(x^{(0)}+\epsilon) |^2 \right]\] <p>Here, $\epsilon$ represents the noise added to the clean data $x^{(0)}$ to obtain $x^{(t)}$. Taking a look at our objective for the $x^{(0)}$-parameterisation, we are aiming to achieve something which is $\propto x^{(0)} - x^{(0)}_{\theta}(x^{t}, t-1)$.</p> <p>Seeing it this way, we can see the resemblance of the denoising autoencoder to this specific parameterisation of a diffusion model.</p> <h2 id="denoising-score-matching-dsm">Denoising Score Matching (DSM)</h2> <p>Denoising score matching (DSM) is a technique used to estimate a score function. The score function is defined as <em>the gradient of the log probability density function of the data</em>. OK, slow down, what does that mean?</p> <table> <tbody> <tr> <td>Well, remember that $q(x^{(t-1)}</td> <td>x^{(0)}, x^{(t)})$ is our noising process. The score is the change in this noising process across the noising schedule, which changes with $x$. In the context of diffusion models, DSM is therefore closely related to the $\epsilon$-parameterisation, which essentially parameterises the change between steps in the noising process.</td> </tr> </tbody> </table> <p>In the $\epsilon$-parameterisation, the objective is to predict the noise added to the clean data $x^{(0)}$ to obtain the noisy data $x^{(t)}$. A neural network $g_\theta$ is trained to map the noisy input $x^{(t)}$ to the noise $\epsilon:</p> \[ϵ_{\theta} = g_{\theta}(x^{(t)})\] <p>As with our DAE discussion, lets have a look at a simple DSM training objective:</p> \[\mathcal{L}_{DSM} = \mathbb{E}_{x_0, t, \epsilon} \left[ | \epsilon - g_\theta(x^{(t)}) |^2 \right]\] <p>By minimizing this loss, the neural network learns to accurately predict the noise, which is essential for the $\epsilon$-parameterisation of diffusion models.</p> <p>Now we mentioned a score function, which is written as $\nabla_{x^{(t)}}\log p(x^{(t)})$ indirectly. Since the noise $\epsilon$ is related to the score function through the gradient of the log probability density, predicting $\epsilon$ effectively helps in estimating the score function.</p> <p>Anyway, score matching is an interesting topic which I’m not going to dwell too much on here but essentially it shares many concepts with denoising diffusion models - where the $\epsilon$-parameterisation is basically practical implementation of score matching.</p> <h2 id="defining-a-loss-function">Defining a Loss Function</h2> <p>OK, we’ve been around the block a bit and discussed some technical stuff, but just to wrap up this post, I’m going to drop a loss function here which was introduced by Ho, et. al., (2020) in the seminal paper on denoising diffusion models:</p> \[\mathcal{L}(\theta) = -\frac{T}{2}\mathbb{E}_{t}\left[\left(\epsilon^{(t)} - \epsilon^{(t)}_{\theta}(\Lambda_t x^{(0)} + \sqrt{1-\Lambda^{2}_t} \epsilon^{(t)}, t-1)\right)^2\right]\] <p>where $\Lambda_t = \prod_{t^\prime=1}^{t}\lambda_{t^\prime}$. Hopefully, you are able to see that this loss function follows quite nicely from some of the discussions we have had in earlier sections.</p> <p>OK, great! Thanks for reading this post, if you have made it this far! Although technical, I hope it has given you a bit more of an intuitive explanation behind some of the main mathematical concepts of diffusion models.</p> </div> </article> </div> </div> <footer class="sticky-bottom mt-5" role="contentinfo"> <div class="container"> © Copyright 2025 Jamie McGowan. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2930004b8d7fcd0a8e00fdcfc8fc9f24"></script> <script defer src="/assets/js/common.js?4a129fbf39254905f505c7246e641eaf"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>